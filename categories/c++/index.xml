<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Lilith Sangreal</title>
    <link>https://lilithsangreal.com/categories/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Lilith Sangreal</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 05 Feb 2023 19:55:58 +0800</lastBuildDate><atom:link href="https://lilithsangreal.com/categories/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43; 模板编程无痛入门</title>
      <link>https://lilithsangreal.com/p/cpp-metaprogramming-tutorails/</link>
      <pubDate>Sun, 05 Feb 2023 19:55:58 +0800</pubDate>
      
      <guid>https://lilithsangreal.com/p/cpp-metaprogramming-tutorails/</guid>
      <description>程序如果不能在运行时完成工作，那就只能在编译时完成工作 —— 维基百科
 本文是一个非常适合新手阅读的模板元编程的入门教程。但仍然需要你有一些基础的 C++ 能力，但不需要很多。
如果你像我一样是个C++菜鸡，但大概能够理解 C++ 的面对对象编程和范型的概念。那么阅读并理解本文内容仍然不成问题。
模板元编程是什么？ 这里有一个来自维基百科的定义：
 模板元编程（英语：Template metaprogramming，缩写：TMP）是一种元编程技术，编译器使用模板产生暂时性的源码，然后再和剩下的源码混合并编译。这些模板的输出包括编译时期常量、数据结构以及完整的函数。
 如果这个描述仍然让你感到费解，那么这里有另外一个定义：
 元编程是程序作者像正常程序操作数据一样操作程序本身的手段。  如果这句话仍然让你感到抽象。那你可以从性能的角度来理解：
 使用元编程能力，我可以把运行时需要做的事情，移动到编译期来做，提升我的程序性能——当然这反之会提升你的编译时间，正如我在文章最开头提到的那样。  或者，可以从你将要做的工作来理解：
 我想要编写一些给同事、同学或是社区使用的框架代码。这些代码我想尽可能简洁且灵活（最基础的范型提供了一些这样的能力，但深入使用模板元编程可以做得更多）。或者想给 C++ 本身添加一些能力，制作一些语法糖。  那也许，你将不得不了解一些元编程的技术。
使用元编程，一点理由…… 这里有一张来自 Walter E. Brown 的实验结果（Cppcon 2014）。
使用模版元编程技术实现的 pow “函数”比 std::pow() 性能高出很多倍。
模版特化与 Type Traits 简单了解过范型的就能知道，普通的函数只能提供给函数声明时指定的类型使用，而模板函数传入多种数据类型。
比如定义一个函数叫：
1 2 3 4 5 6 7 8 9 10 11 12  /// 以下代码示例来自 https://blog.aaronballman.com/2011/11/a-simple-introduction-to-type-traits/  template &amp;lt;typename T&amp;gt; T byte_swap( T value ) { unsigned char *bytes = reinterpret_cast&amp;lt; unsigned char * &amp;gt;( &amp;amp;value ); for (size_t i = 0; i &amp;lt; sizeof( T ); i += 2) { unsigned char v = bytes[ i ]; bytes[ i ] = bytes[ i + 1 ]; bytes[ i + 1 ] = v; } return value; }   不用仔细阅读这个函数的实现。简单来说，这个函数传入一个 32 位的数字 0x11223344 会得到返回值 0x22114433。也可以传入一个 16 位的数字 0x1122 得到 0x2211。</description>
    </item>
    
    <item>
      <title>Protocol Buffers 编译器源码阅读</title>
      <link>https://lilithsangreal.com/p/google-protocol-buffers-notes/</link>
      <pubDate>Fri, 29 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lilithsangreal.com/p/google-protocol-buffers-notes/</guid>
      <description>Protocol Buffers 编译器源码阅读 前言 Protocol Buffers （简称 pb/protobuf） 是谷歌公司开发的一款跨平台跨语言的结构数据序列化框架，可以使用 protobuf 的提供的编译器将定义好的数据模型（ proto文件 ）编译为各种语言，提供对应的特殊数据结构的序列化、反序列化能力。protobuf 性能好，语法简洁，广泛应用于 rpc 框架中，为其提供编解码的能力。
除此之外，protobuf 还是一个优秀的 C++ 开源项目 Github，在社区里询问阅读什么项目提升自己的 C++ 编码能力时，也有很多人推荐阅读 protobuf 的源码。
出于工作上的原因，最近我也对 protobuf 的编译器源码（Protocol buffers 3）进行一定阅读，发现它的代码整洁，逻辑清晰，设计也非常好。因此写一篇这样的文章记录一下阅读的一些收获。
编译器相关知识 如果完全没有编译器相关的知识，那么阅读 protobuf 的源码是无从下手的。和寻常的编译器一样，protobuf 也可以分为编译器前端和后端，并完成了一个从源语言到目标语言的转换。对于传统编程语言来说，即是从源代码到机器直接执行的机器码的转换。
如图所示，对于 protobuf 来说，源语言就是一个 proto 文件，定义了数据结构。而目标语言则是对应语言的源代码。以便于各种语言直接调用使用。
目前 protobuf 支持的语言如下。也就是说，定义好的 proto 文件会转换为下列语言的源代码。
对于编译器来说，前端主要完成的工作是词法分析，语法分析，语义分析。
假设我们已经完成了预编译器的工作（一般包括去除空格，插入头文件，展开宏等等……事实上，根据不同的语言复杂程度，预编译器的工作也可能会非常复杂）。假设我们的语言非常简单，不需要引入什么头文件，展开宏等等，那么输入的目标语言将会被去除多余的空格和换行符。
这样，对于编译器来说，目标语言只是一串连续的字母和特殊符号的序列，比如：
1  whiletrue;   单个字母和符号一般不能表达什么含义，因此 词法分析 是将单词组合拆分成 token（单词）的形式， 如上述代码中的 while 和 true。经过词法分析，字母和特殊符号的序列就转化为了一串由单词形式组成的序列。
而 语法分析 则是将这个单词的序列组织成一个抽象语法树（Abstract Syntax Tree，AST），后文会针对protobuf使用的语法分析方式介绍这一过程的实例。
至此为止，其实编译器也只是将源语言，从一种不包含结构的序列形式转换成了含有结构的形式。这其中产生了任何的理解了吗？没有，至此位置，计算机只是对数据进行了一些处理工作，但并不知道我们的代码做了什么事情。
但是组织一棵树的形式，则为语言初步理解源代码做了什么，做的事情是否合法提供了条件。编译器会反复阅读这棵树，根据这棵树的结构来分析语义，来判断程序员输入的东西是否合理。在这个过程中，编译器会为AST的每个节点填写一些属性。这就是 语义分析。
LL(1) 文法 </description>
    </item>
    
  </channel>
</rss>
